
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Manual &#8212; OptBayesExpt 1.0.0 documentation</title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />

    <link rel="stylesheet" href="https://pages.nist.gov/nist-header-footer/css/nist-combined.css" type="text/css" />
    <script src="https://code.jquery.com/jquery-1.12.4.min.js" type="text/javascript"></script>
    <script src="https://pages.nist.gov/nist-header-footer/js/nist-header-footer.js" type="text/javascript" defer="defer"></script>

<script type="text/javascript" src="https://pages.nist.gov/leaveNotice/js/jquery.leaveNotice-nist.min.js"></script>
<script>
$(document).ready(function(){
  // Mark external (non-nist.gov) A tags with class "external"
  //If the adress start with https and ends with nist.gov
  var re_nist = new RegExp('^https?:\/\/((^\/)*\.)*nist\\.gov(\/|$)');
  //Regex to find address that start with https
  var re_absolute_address = new RegExp('^((https?:)?\/\/)');
  $("a").each(function(){
    var url=$(this).attr('href');
    if(re_nist.test(url) || !re_absolute_address.test(url)){
      $(this).addClass('local');
    }else{
      //This a href appears to be external, so tag it
      $(this).addClass('external');
    }
  });
  // Add leaveNotice to external A elements
  $('a.external').leaveNotice();
});
</script>
<link rel="stylesheet" type="text/css" href="https://pages.nist.gov/leaveNotice/css/jquery.leaveNotice.css" />

<script async type="text/javascript" id="_fed_an_ua_tag" src="https://dap.digitalgov.gov/Universal-Federated-Analytics-Min.js?agency=NIST&subagency=github&pua=UA-42404149-54&yt=true&exts=ppsx,pps,f90,sch,rtf,wrl,txz,m1v,xlsm,msi,xsd,f,tif,eps,mpg,xml,pl,xlt,c">
</script>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">OptBayesExpt 1.0.0 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="manual">
<h1>Manual<a class="headerlink" href="#manual" title="Permalink to this headline">¶</a></h1>
<div class="line-block">
<div class="line">R. D. McMichael <a class="reference external" href="mailto:rmcmichael&#37;&#52;&#48;nist&#46;gov">rmcmichael<span>&#64;</span>nist<span>&#46;</span>gov</a></div>
<div class="line">National Institute of Standards and Technology</div>
<div class="line">Gaithersburg, MD USA</div>
<div class="line">March 29, 2020</div>
</div>
<div class="section" id="contents">
<h2>Contents<a class="headerlink" href="#contents" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="#introduction">Introduction</a></p></li>
<li><p><a class="reference external" href="#philosophy-and-goals">Philosophy and goals</a></p></li>
<li><p><a class="reference external" href="#requirements-for-users">Requirements</a></p></li>
<li><p><a class="reference external" href="#demos">Demos</a></p></li>
<li><p><a class="reference external" href="#theory-of-operation">Theory of Operation</a></p></li>
</ul>
</div>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This manual describes an implementation of optimal Bayesian experimental
design methods to control measurement settings in order to efficiently
determine model parameters. In situations where parametric models would
conventionally be fit to measurement data in order to obtain model
parameters, these methods offer an adaptive measurement strategy capable
of reduced uncertainty with fewer required measurements. These methods
are therefore most beneficial in situations where measurements are
expensive in terms of money, time, risk, labor or discomfort. The price
for these benefits lies in the complexity of automating such
measurements and in the computational load required. It is the goal of
this package to assist potential users in overcoming at least the
programming hurdles.</p>
<p>Optimal Bayesian experimental design is not new, at least not in the
statistics community. A review paper from 1995 by <a class="reference external" href="https://projecteuclid.org/euclid.ss/1177009939">Kathryn Chaloner and
Isabella Verinelli</a>
reveals that the basic methods had been worked out in preceding decades.
The methods implemented here closely follow <a class="reference external" href="http://dx.doi.org/10.1016/j.jcp.2012.08.013">Xun Huan and Youssef M.
Marzouk</a> which
emphasizes simulation-based experimental design. Optimal Bayesian
experimental design is also an active area of research.</p>
<p>There are at least three important factors that encourage application of
these methods today. First, the availability of flexible, modular
computer languages such as Python. Second, availability of cheap
computational power. Most of all though, an increased awareness of the
benefits of code sharing and reuse is growing in scientific communities.</p>
</div>
<div class="section" id="philosophy-and-goals">
<h2>Philosophy and goals<a class="headerlink" href="#philosophy-and-goals" title="Permalink to this headline">¶</a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><dl class="simple">
<dt>If it sounds good, it is good.</dt><dd><p>– Duke Ellington</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p>Jazz legend Duke Ellington was talking about music, where it’s all about
the sound. For this package, it’s all about being useful. The goals are
modest: to adapt some of the developments in optimal Bayeseian
experimental design research for practical use in laboratory settings,
giving users tools to make better measurements.  This project adopts a
“runs good” philosophy:</p>
<ul class="simple">
<li><p>If it’s a struggle to use, it can’t run good.</p></li>
<li><p>If technical jargon is a barrier, it can’t run good</p></li>
<li><p>If the user finds it useful, it runs good.</p></li>
<li><p>If it runs good, it is good.</p></li>
</ul>
</div>
<div class="section" id="requirements-for-users">
<h2>Requirements for users<a class="headerlink" href="#requirements-for-users" title="Permalink to this headline">¶</a></h2>
<p>It takes a little effort to get this software up and running. Here’s
what a user will need to supply to get started.</p>
<ol class="arabic simple">
<li><p>Python 3.x with the <code class="docutils literal notranslate"><span class="pre">numpy</span></code> python package</p></li>
<li><p>An experiment that yields measurement results with uncertainty
estimates.</p></li>
<li><p>A reliable parametric model for the experiment, typically a function with
parameters to be determined.</p></li>
<li><p>A working knowledge of Python programming, enough to follow examples
and program a model function.</p></li>
</ol>
</div>
<div class="section" id="demos">
<h2>Demos<a class="headerlink" href="#demos" title="Permalink to this headline">¶</a></h2>
<div class="section" id="locating-a-lorentzian-peak">
<h3>Locating a Lorentzian peak<a class="headerlink" href="#locating-a-lorentzian-peak" title="Permalink to this headline">¶</a></h3>
<div class="figure align-default" id="id2">
<img alt="Comparison of measure-then-fit and OBED method" src="_images/demoLorentzfig1.png" />
<p class="caption"><span class="caption-text">Comparison of measure-then-fit and OBED method</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</div>
<p>Figure 1: A comparison of measure-then-fit (left) and optimal Bayesian
experimental design (right). Both methods measure the same “true” peak
with Gaussian noise added (<span class="math notranslate nohighlight">\(\sigma = 1\)</span>) independently. The peak
parameters are selected randomly: center between 2 and 4, height between
2 and 5, background between -1 and 1 and peak width between 0.1 and 0.3.
On the left, 30 evenly-spaced “measurements” are made and fit using
<code class="docutils literal notranslate"><span class="pre">scipy.optimize.curve_fit()</span></code>. A curve using the best-fit parameters is
plotted for comparison with the true curve. The diagonal element of the
covariance matrix is taken as the square of the uncertainty. On the
right, the optimal Bayes experimental design method is used
sequentially. Iterations stop when the standard deviation of the <code class="docutils literal notranslate"><span class="pre">x0</span></code>
peak center distribution is less than the uncertainty of the fit on the
left. Green curves are generated from random draws from the parameter
distribution at the stopping point. Typical runs of this example require
approximately 1/4 to 1/2 as many measurements as the measure-then-fit
method. See <code class="docutils literal notranslate"><span class="pre">Demos/demoLorentzian.py</span></code>.</p>
</div>
<div class="section" id="id1">
<h3>Locating a Lorentzian peak<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<div class="figure align-default">
<img alt="Behavior and results of a sequential Bayesian experimental design approach to measurement a Lorentzian peak." src="_images/sequentialLorentzian.png" />
</div>
<p>Figure 1.  Behavior and results of a sequential Bayesian experimental design
approach to measurement of a Lorentzian peak. The unknown parameters are
the peak position and amplitude and the background level, and the peak
width is fixed. Panel (a) shows the true curve in red and the simulated
measurement data after 500 measurements. The signal to noise ratio is
approximately 1.0.  The algorithm focuses measurement resources near the
peak as quantified by the histogram in (c). Measurements far from the peak
reduce uncertainty in the background level.  Panels (b) and (d) illustrate
how the process evolves.  (b) plots the standard deviation of the peak
center, and (d) plots the measurement settings. For the first 50-ish
measurements, the settings are scattered and the standard deviation drops
slowly. After 50-ish measurements, the standard deviation drops quickly and
the settings concentrate on the peak level.  At around 150 measurements, the
system enters a steady-state pattern of settings near the peak with less
frequent measurements of the background.  In this stage, the standard
deviation typically reduces proportional to <span class="math notranslate nohighlight">\(1/\sqrt{N}\)</span>.</p>
</div>
<div class="section" id="measurement-speedup">
<h3>Measurement speedup<a class="headerlink" href="#measurement-speedup" title="Permalink to this headline">¶</a></h3>
<div class="figure align-default">
<img alt="Mechanism of speedup" src="_images/rootN.png" />
</div>
<p>Figure 2: A different view of the Lorentzian peak problem, contrasting
efficiency differences between methods. The left panel shows results
after 3000 measurements of a spectrum. The simulated experimental noise
is Gaussian with standard deviation <span class="math notranslate nohighlight">\(\sigma = 1\)</span>. In the “average
&amp; fit” method, 100 simulated measurements are averaged at each of 30
points, yielding a uniform uncertainty of
<span class="math notranslate nohighlight">\(\sigma_y = 1/\sqrt{100}\)</span>. In the OptBayesExpt method, the
algorithm focuses attention on the sides of the peak, as shown in the
histogram. The symbol areas are proportional to the weights of the data
points, <span class="math notranslate nohighlight">\(1/\sigma^2\)</span>. The smallest points correspond to
<span class="math notranslate nohighlight">\(\sigma_y = 0.258\)</span>, and the largest to
<span class="math notranslate nohighlight">\(\sigma_y \approx 0.037.\)</span></p>
<p>The right panel plots the evolution of uncertainty in the peak center
<span class="math notranslate nohighlight">\(x_0\)</span> with the number of accumulated measurements. Plotted values
summarize the results of 100 runs, each with 3000 OptBayesExpt
measurments and 15 000 average &amp; fit measurements. Dark lines plot the difference between ‘best’
values and the ‘true’ values as an rms error.  Faint lines plot the standard deviation and
standard uncertainty of individual runs.  Both the average &amp; fit
technique and the OptBayesExpt method scale like
<span class="math notranslate nohighlight">\(\sigma_{x0} \propto 1/\sqrt{N}\)</span> (<span class="math notranslate nohighlight">\(N\)</span> = measurement number)
for large <span class="math notranslate nohighlight">\(N\)</span>, but the OptBayesExpt requires approximately 4
times fewer measurements to achieve the same uncertainty.</p>
<p>Details: The average and fit method used <code class="docutils literal notranslate"><span class="pre">scipy.optimize.curve_fit()</span></code>. The uncertainty plotted
here is the square root of the diagonal element in the covariance matrix. For both methods, the peak
height, background level and peak center are treated as unknowns, and
the half-width line width is fixed at 0.3. See <code class="docutils literal notranslate"><span class="pre">demos/fit_vs_obe_makedata.py</span></code> and
<code class="docutils literal notranslate"><span class="pre">demos/fit_vs_obe_plots.py</span></code></p>
</div>
<div class="section" id="tuning-a-pi-pulse">
<h3>Tuning a <span class="math notranslate nohighlight">\(\pi\)</span> pulse<a class="headerlink" href="#tuning-a-pi-pulse" title="Permalink to this headline">¶</a></h3>
<div class="figure align-default" id="id3">
<img alt="measurements of transition probability vs pulse length and detuning" src="_images/pipulsefig.png" />
<p class="caption"><span class="caption-text">measurements of transition probability vs pulse length and detuning</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</div>
<p>Figure 3: A <span class="math notranslate nohighlight">\(\pi\)</span> pulse is a method of inverting spins that is
frequently used in nuclear magnetic resonance (NMR and MRI) and pulsed
electron paramagnetic resonance (EPR). In order to be accurate, the
duration and frequency of the radio-frequency pulse must be tuned. On
the left, the background image displays the model photon counts for
optically detected spin manipulation for different frequency detunings
and pulse lengths. White indicates the expected result for spin up and
black, spin down. Points indicate simulated measurement settings, with
sequence in order from white to dark red. Simulated measurements have
1<span class="math notranslate nohighlight">\(\sigma\)</span> uncertainties of <span class="math notranslate nohighlight">\(\sqrt{N} \approx 316\)</span>. The right panel displays the
evolution of the probability distribution function with the number “N”
of measurements. See <code class="docutils literal notranslate"><span class="pre">Demos.pipulse.py</span></code>.</p>
</div>
<div class="section" id="slope-intercept">
<h3>Slope Intercept<a class="headerlink" href="#slope-intercept" title="Permalink to this headline">¶</a></h3>
<div class="figure align-default" id="id4">
<img alt="Straight line measurement examples" src="_images/slopeintercept.png" />
<p class="caption"><span class="caption-text">Straight line measurement examples</span><a class="headerlink" href="#id4" title="Permalink to this image">¶</a></p>
</div>
<p>Figure 4: This demo uses a straight line model, a case where the “best”
measurement settings are known in advance; measurements at the ends of a
line are the most effective at reducing uncertainty in the slope and
intercept values. For reassurance that the straight line model is
appropriate, some measurements in the in the middle of the span might
also be desired. The OptBayesExpt class provides two methods for
flexibility in measurement selection. The <code class="docutils literal notranslate"><span class="pre">opt_setting()</span></code> method
selects the setting with the highest <em>utility</em> <span class="math notranslate nohighlight">\(\max[U(x)]\)</span>. The
first panel shows that it behaves as expected, choosing measurements at
the ends of the line. The <code class="docutils literal notranslate"><span class="pre">good_setting()</span></code> method is more flexible,
selecting settings with a probability based on the <em>utility</em> and the
<code class="docutils literal notranslate"><span class="pre">pickiness</span></code> parameter. The 2nd through 4th panels show that the
<code class="docutils literal notranslate"><span class="pre">good_setting()</span></code> algorithm selects more diverse setting values as the
<code class="docutils literal notranslate"><span class="pre">pickiness</span></code> is reduced. Note also that the standard deviations
increase from left to right as measurement resources are diverted away
from reducing uncertainty. Each run uses 100 points. See
<code class="docutils literal notranslate"><span class="pre">demos/line_plus_noise.py</span></code>.</p>
</div>
</div>
<div class="section" id="theory-of-operation">
<h2>Theory of operation<a class="headerlink" href="#theory-of-operation" title="Permalink to this headline">¶</a></h2>
<p>The optimal Bayes experimental design method incorporates two main jobs,
which we can describe as “learning early” and “making good decisions”</p>
<div class="section" id="learning-early">
<h3>Learning early<a class="headerlink" href="#learning-early" title="Permalink to this headline">¶</a></h3>
<p>By interpreting measurement data as soon as it becomes available, sequential Bayesian
experimental design gains a critical advantage over the traditional measure-then-fit design.
With a measure-then-fit strategy, we get information about parameters only at the very end of the
process, after all the measurements and fitting are done. In contrast, the optimal Bayesian
experimental design method updates our parameter knowledge with each measurement result, so
that information-based decisions can be made as data is collected.</p>
<p>The process of digesting new data is Bayesian inference, which frames
parameter knowledge in terms of a probability distribution <span class="math notranslate nohighlight">\(p(\theta)\)</span> for an array of
parameters <span class="math notranslate nohighlight">\(\theta = [ \theta_0, \theta_1, ...]\)</span>. The familiar notation <span class="math notranslate nohighlight">\(a\pm \sigma\)</span>
is often a shorthand description of a Gaussian probability distribution. A broad distribution
<span class="math notranslate nohighlight">\(p(\theta)\)</span> corresponds to large uncertainty, and if <span class="math notranslate nohighlight">\(p(\theta)\)</span> is a narrow
distribution, the uncertainty is small.</p>
<p>When new measurement results <span class="math notranslate nohighlight">\(m\)</span> are taken in to account, there will be a new,
revised probability distribution <span class="math notranslate nohighlight">\(p(\theta|m)\)</span>. The vertical bar in the notation
<span class="math notranslate nohighlight">\(p(\theta|m)\)</span> indicates a conditional probability, so <span class="math notranslate nohighlight">\(p(\theta|m)\)</span> is the
distribution of <span class="math notranslate nohighlight">\(\theta\)</span> values <em>given</em> <span class="math notranslate nohighlight">\(m\)</span>.</p>
<p>Bayes’ rule provides</p>
<div class="math notranslate nohighlight">
\[p(\theta|m) = \frac{p(m|\theta) p(\theta)}{p(m)}.\]</div>
<p>All of the terms here have technical names. The left side is the
<em>posterior</em> distribution, i.e. the distribution of parameters
<span class="math notranslate nohighlight">\(\theta\)</span> after we include <span class="math notranslate nohighlight">\(m\)</span>. On the right, distribution
<span class="math notranslate nohighlight">\(p(\theta)\)</span> is the <em>prior</em>, representing what we knew about the
parameters <span class="math notranslate nohighlight">\(\theta\)</span> before the measurement. In the denominator,
<span class="math notranslate nohighlight">\(p(m)\)</span> is called the <em>evidence</em>, but because it has no <span class="math notranslate nohighlight">\(\theta\)</span>
dependence, it functions just a normalizing constant in this situation.
As wrong as this sounds, we will ignore the <em>evidence</em>.</p>
<p>The term that requires attention is in the numerator; <span class="math notranslate nohighlight">\(p(m|\theta)\)</span> is called the
<em>likelihood</em>. It’s the probability of getting measurement <span class="math notranslate nohighlight">\(m\)</span>
given variable parameter values <span class="math notranslate nohighlight">\(\theta\)</span>.  Less formally, the <em>likelihood</em> answers the
question: “How well does the model explain the measured value
<span class="math notranslate nohighlight">\(m\)</span>, when the model uses different parameter values <span class="math notranslate nohighlight">\(\theta\)</span>?”</p>
<p>In practice, <span class="math notranslate nohighlight">\(m_i\)</span> will be a fixed measurement result to “plug in” for <span class="math notranslate nohighlight">\(m\)</span>. It’s
important to keep sight of the fact that <span class="math notranslate nohighlight">\(p(m_i|\theta)\)</span> is still a function of
theta. Conceptually, we can try out different parameter values in our
model to produce a variety of measurement predictions. Some parameter
values (the more likely ones) will produce model values closer to
<span class="math notranslate nohighlight">\(m_i\)</span> and for other parameters, (the less likely ones), model
model value will be further away.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">optbayesexpt.OptBayesExpt</span></code> class requires the user to report a measurement record
<span class="math notranslate nohighlight">\(m_i\)</span> that includes the measurement settings <span class="math notranslate nohighlight">\(x_i\)</span>, the “value” <span class="math notranslate nohighlight">\(y_i\)</span>, and
uncertainty <span class="math notranslate nohighlight">\(\sigma_i\)</span>. Together, <span class="math notranslate nohighlight">\(y_i\)</span> and <span class="math notranslate nohighlight">\(\sigma_i\)</span> are more than fixed
numbers; they
are shorthand for a probability that a noise-free measurement would yield a value <span class="math notranslate nohighlight">\(y\)</span>.
<span class="math notranslate nohighlight">\(y\)</span> given a mean value <span class="math notranslate nohighlight">\(y_i\)</span>. If this distribution is symmetric, like a Gaussian, for
example, then <span class="math notranslate nohighlight">\(p(y|y_i, \sigma_i) = p(y_i|y, \sigma_i)\)</span>, the probability of measuring
<span class="math notranslate nohighlight">\(y_i\)</span> given a mean value <span class="math notranslate nohighlight">\(y\)</span> that’s provided by the experimental model <span class="math notranslate nohighlight">\(y=y
(x_i,\theta)\)</span>.</p>
<div class="math notranslate nohighlight">
\[p(m_i|\theta) = \frac{1}{\sqrt{2\pi}\sigma_i}
\exp\left[-\frac{[y_i - y(x_i, \theta)]^2 }{ 2\sigma_i^2 } \right].\]</div>
<p>With this <em>likelihood</em>, Bayes theorem provides the updated  <span class="math notranslate nohighlight">\(p(\theta|m_i)\)</span>.
Then, another measurement <span class="math notranslate nohighlight">\(m_j\)</span> can update <span class="math notranslate nohighlight">\(p(\theta|m_i)\)</span> to
<span class="math notranslate nohighlight">\(p(\theta|m_j, m_i, \ldots)\)</span> and so on. In order to keep the
notation readable, we’ll adopt a convention that <span class="math notranslate nohighlight">\(p(\theta)\)</span>
always represents the most up-to-date parameter distribution that we
have.</p>
<p>This approach assumes that our model function <span class="math notranslate nohighlight">\(y(x, \theta)\)</span> is a good description of our
system, and that the measurement noise is Gaussian with standard deviation
<span class="math notranslate nohighlight">\(\sigma_i\)</span>. On one hand we have to admit that these assumptions don’t allow us to
address all important cases. On the other hand, these are the same
assumptions we often make in doing least-squares curve fitting.</p>
<p>The method described above puts the responsibility for determining
measurement uncertainty on the measurement reporter, but as an experimental result, uncertainty is
generally a measurement output, not an input.  If uncertainty is a parameter to be determined, it
enters the process through the likelihood function given above, but it is not part of the model
function <span class="math notranslate nohighlight">\(y(x_i, \theta)\)</span>. See <code class="docutils literal notranslate"><span class="pre">demos/line_plus_noise.py</span></code> for an example.</p>
</div>
<div class="section" id="making-good-decisions">
<h3>Making good decisions<a class="headerlink" href="#making-good-decisions" title="Permalink to this headline">¶</a></h3>
<p>The next important job in the process is figuring out good measurement
settings. The goal is to make the parameter probability distribution
<span class="math notranslate nohighlight">\(p(\theta)\)</span> narrow while minimizing cost. More formally, the
challenge is to develop a <em>utility function</em> <span class="math notranslate nohighlight">\(U(x)\)</span> that helps us
to predict and compare the relative benefits of measurements made with
different possible experimental settings <span class="math notranslate nohighlight">\(x\)</span>.</p>
<p>Qualitatively, the mechanism for choosing measurement values hinges on the model’s connection
between parameter values <span class="math notranslate nohighlight">\(\theta\)</span> and measurement results <span class="math notranslate nohighlight">\(y\)</span>.
Consider a sampling of several sets of parameter values <span class="math notranslate nohighlight">\(\theta_i\)</span>.  With these parameter
sets, the model can produce a collection of output curves <span class="math notranslate nohighlight">\(y_i(x)\)</span>, and generally these
curves will be closer together for some settings <span class="math notranslate nohighlight">\(x\)</span> and further apart for others.
Intuitively, little would be learned by measuring at <span class="math notranslate nohighlight">\(x\)</span> values where the curves
agree.  Instead, it would do the most good to “pin down” the results with a measurement at an
<span class="math notranslate nohighlight">\(x\)</span> where the predicted <span class="math notranslate nohighlight">\(y_i(x)\)</span> curves disagree.</p>
<p>By drawing samples from the updated parameter distribution <span class="math notranslate nohighlight">\(p(\theta)\)</span> the mechanism above
focuses attention on the relevant parts of parameter space, and through the model to relevant
settings. Or, stated slightly differently, using an updated parameter distribution helps to avoid
wasting measurement resources on low-impact measurements.</p>
<div class="section" id="estimate-benefits">
<h4>Estimate benefits<a class="headerlink" href="#estimate-benefits" title="Permalink to this headline">¶</a></h4>
<p>To translate such a qualitative argument into code, “doing the most good”
must be defined more precisely in terms of desired changes in
the parameter distribution <span class="math notranslate nohighlight">\(p(\theta)\)</span>. Usually, the goal in
determining model parameters is to get unambiguous results with small uncertainty. The <em>information
entropy</em> provides a measure of something like a probability distribution. The information entropy
of a probability distribution <span class="math notranslate nohighlight">\(p(a)\)</span> is defined as</p>
<div class="math notranslate nohighlight">
\[E = -\int da\; p(a)\; \ln[p(a)].\]</div>
<p>Note that the integrand above is zero for both <span class="math notranslate nohighlight">\(p(a) = 1\)</span> and
<span class="math notranslate nohighlight">\(p(a)=0\)</span>. It’s the intermediate values encountered in a
spread-out distribution where the information entropy accumulates. For
common distributions, like rectangular or Gaussian, that have
characteristic widths <span class="math notranslate nohighlight">\(w\)</span> the entropy goes like <span class="math notranslate nohighlight">\(\ln(w) + C\)</span> with <span class="math notranslate nohighlight">\(C\)</span> values
depending on the shape of the distribution.</p>
<p>Now we can define “doing the most good” in terms of how much
entropy change <span class="math notranslate nohighlight">\(E\)</span>(<em>posterior</em>) - <span class="math notranslate nohighlight">\(E\)</span>(<em>prior</em>) we
might get for predicted measurement values <span class="math notranslate nohighlight">\(y\)</span> at different
settings <span class="math notranslate nohighlight">\(x\)</span>. Actually, we use something slightly
different called the Kulback-Liebler divergence:</p>
<div class="math notranslate nohighlight">
\[D^{KL}(y,x) = \int d\theta\; p(\theta |y,x)
\ln \left[ \frac{p(\theta | y,x)}{p(\theta)}\right].\]</div>
<p>In this expression <span class="math notranslate nohighlight">\(p(\theta | y,x)\)</span> is a speculative parameter
distribution we would get if we happened to measure a value <span class="math notranslate nohighlight">\(y\)</span>
using settings <span class="math notranslate nohighlight">\(x\)</span>. By itself, <span class="math notranslate nohighlight">\(D^{KL}(y,x)\)</span> doesn’t work
as a utility function <span class="math notranslate nohighlight">\(U(x)\)</span> because it depends on this
arbitrary possible measurement value <span class="math notranslate nohighlight">\(y\)</span>. So we need to average
<span class="math notranslate nohighlight">\(D^{KL}\)</span>, weighted by the probability of measuring <span class="math notranslate nohighlight">\(y\)</span>.</p>
<div class="math notranslate nohighlight">
\[U(x) \propto \int dy \int d\theta\; p(y|x) p(\theta |y,x)
\ln \left[ \frac{p(\theta | y,x)}{p(\theta)}\right].\]</div>
<p>With two applications of Bayes rule and some rearrangement this expression for
<span class="math notranslate nohighlight">\(U(x)\)</span> can be rewritten as the difference between two information entropy-like terms:</p>
<dl class="field-list">
<dt class="field-odd">Term 1</dt>
<dd class="field-odd"><p>The information entropy of <span class="math notranslate nohighlight">\(p(y|x)\)</span>, the distribution of
measurement values expected at setting <span class="math notranslate nohighlight">\(x\)</span>. Importantly this distribution
includes likely variations of <span class="math notranslate nohighlight">\(\theta.\)</span> Explicitly,</p>
<div class="math notranslate nohighlight">
\[p(y|x) = \int d\theta'\; p(\theta') p(y|\theta',x)\]</div>
<p>Qualitatively, this term is the information entropy of the predicted measurement values
including both measurement noise and the effects of parameter uncertainty.</p>
</dd>
<dt class="field-even">Term 2</dt>
<dd class="field-even"><p>The other term is the information entropy of <span class="math notranslate nohighlight">\(p(y|\theta,x)\)</span> the measurement value
distribution when <span class="math notranslate nohighlight">\(\theta\)</span> and <span class="math notranslate nohighlight">\(x\)</span> are fixed, i.e. the entropy of just the
measurement noise distribution. The entropy of this distribution is averaged over
<span class="math notranslate nohighlight">\(\theta\)</span> values.</p>
<div class="math notranslate nohighlight">
\[\int d\theta\; p(\theta) \int dy\; p(y|\theta,x) \ln [ p(y|\theta, x) ]\]</div>
</dd>
</dl>
<p>Term 1 is the entropy of the <span class="math notranslate nohighlight">\(\theta\)</span>-averaged <span class="math notranslate nohighlight">\(y\)</span>
distribution and Term 2 is the <span class="math notranslate nohighlight">\(\theta\)</span> average of the entropy of
the <span class="math notranslate nohighlight">\(y\)</span> distribution. Loosely, Term 1 is a measure of the spread
in <span class="math notranslate nohighlight">\(y\)</span> values due to both measurement noise and likely parameter
variations, while term 2 is (mostly) just the measurement noise.</p>
<p>An accurate calculation of <span class="math notranslate nohighlight">\(U(x)\)</span> is a big job, requiring integrals over all
parameter space and also all possible measurement outcomes, once for every possible setting.
Fortunately, in keeping with the “runs good” project philosophy, accuracy is not required.
All we require of an approximate utility function is that provides a guide for non-stupid
decisions. It is not critical that the absolute best measurement choice is made
every single time.  It is only necessary to know if there are values of <span class="math notranslate nohighlight">\(x\)</span>
where <span class="math notranslate nohighlight">\(U (x)\)</span> is large compared to other
<span class="math notranslate nohighlight">\(x\)</span>.  Even if we don’t choose the absolute best setting,
a “pretty good” choice will do more good than an uninformed choice.</p>
<p>Consider an approximate calculation of <span class="math notranslate nohighlight">\(U^*(x)\)</span>
where all of the distributions are assumed to be normal (Gaussian). The information
entropy of the normal distribution has a term that goes like
<span class="math notranslate nohighlight">\(\ln\)</span>(width). Term 1 from above is a convolution of the
measurement noise distribution (width = <span class="math notranslate nohighlight">\(\sigma_y\)</span> and the
distribution of model <span class="math notranslate nohighlight">\(y\)</span> values (width =
<span class="math notranslate nohighlight">\(\sigma_{y,\theta}\)</span>) that reflects the connection to the parameter
distribution. A property of normal distributions is that a convolution
of normal distributions is another normal distribution with width =
<span class="math notranslate nohighlight">\(\sqrt{\sigma_{y,\theta}^2 + \sigma_y^2}\)</span>. Under the assumption of
normal distributions, we now have an approximate utility function</p>
<div class="math notranslate nohighlight">
\[U^*(x) \propto \approx \ln(\sqrt{\sigma_\theta^2 + \sigma_y^2}) - \ln(\sigma_y)
        = \frac{1}{2}\ln\left[\frac{\sigma_{y,\theta}(x)^2}{\sigma_y(x)^2}+1\right]\]</div>
<p>This approximation has some reasonable properties. The dependence on
<span class="math notranslate nohighlight">\(\sigma_{y,\theta}\)</span> matches our initial intuition that
high-utility parameters are those where measurements vary a lot due to
parameter variations. The dependence on measurement noise
<span class="math notranslate nohighlight">\(\sigma_y\)</span> also has an intuitive interpretation: that it’s less
useful to make measurements at settings <span class="math notranslate nohighlight">\(x\)</span> where the
instrumental noise is larger. This approximate utility function is
also positive, i.e. more data helps narrow a distribution.</p>
</div>
<div class="section" id="estimate-the-costs">
<h4>Estimate the costs<a class="headerlink" href="#estimate-the-costs" title="Permalink to this headline">¶</a></h4>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Don’t forget the cost</p>
</div>
<p>It is also important to consider the cost associated with different settings,
including possible “travel costs” of moving between settings.  The <em>utility</em> should be divided
by the cost to make setting decisions based on benefit/cost ratios rather than on benefit alone.</p>
<p>In principle, the cost function is as important as the entropy change term detailed above, but
there’s not much to write about it.</p>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Manual</a><ul>
<li><a class="reference internal" href="#contents">Contents</a></li>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#philosophy-and-goals">Philosophy and goals</a></li>
<li><a class="reference internal" href="#requirements-for-users">Requirements for users</a></li>
<li><a class="reference internal" href="#demos">Demos</a><ul>
<li><a class="reference internal" href="#locating-a-lorentzian-peak">Locating a Lorentzian peak</a></li>
<li><a class="reference internal" href="#id1">Locating a Lorentzian peak</a></li>
<li><a class="reference internal" href="#measurement-speedup">Measurement speedup</a></li>
<li><a class="reference internal" href="#tuning-a-pi-pulse">Tuning a <span class="math notranslate nohighlight">\(\pi\)</span> pulse</a></li>
<li><a class="reference internal" href="#slope-intercept">Slope Intercept</a></li>
</ul>
</li>
<li><a class="reference internal" href="#theory-of-operation">Theory of operation</a><ul>
<li><a class="reference internal" href="#learning-early">Learning early</a></li>
<li><a class="reference internal" href="#making-good-decisions">Making good decisions</a><ul>
<li><a class="reference internal" href="#estimate-benefits">Estimate benefits</a></li>
<li><a class="reference internal" href="#estimate-the-costs">Estimate the costs</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/manual.old.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">OptBayesExpt 1.0.0 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright National Institute of Standards and Technology.Not subject to copyright in the United States..
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.4.4.
    </div>
  </body>
</html>